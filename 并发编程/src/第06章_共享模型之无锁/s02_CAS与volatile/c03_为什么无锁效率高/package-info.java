/**
 * 
 */
/**
 * @author 15753
 *
 */
package 第06章_共享模型之无锁.s02_CAS与volatile.c03_为什么无锁效率高;

/*

为什么无锁效率高
	无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时
	候，发生上下文切换，进入阻塞。打个比喻
	线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，
	等被唤醒又得重新打火、启动、加速... 恢复到高速运行，代价比较大
	但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑
	道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还
	是会导致上下文切换


*/